<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>EP08 深入 React-Hook 工作机制：“原则”的背后，是“原理” - 坐和放宽</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ZhangLK"><meta name="msapplication-TileImage" content="https://fastly.jsdelivr.net/gh/ZzzhangLK/Image-Hosting-Service/img/avtor.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ZhangLK"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="深入 React-Hook 工作机制：“原则”的背后，是“原理”"><meta property="og:type" content="blog"><meta property="og:title" content="EP08 深入 React-Hook 工作机制：“原则”的背后，是“原理”"><meta property="og:url" content="http://zzzhanglk.github.io/2023/01/01/frontEnd/inDepthAndSimpleReact/reactStudy-EP8/"><meta property="og:site_name" content="坐和放宽"><meta property="og:description" content="深入 React-Hook 工作机制：“原则”的背后，是“原理”"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s0.lgstatic.com/i/image/M00/89/5F/Ciqc1F_YT0uAT1kZAACw9EfbQe8557.png"><meta property="og:image" content="https://s0.lgstatic.com/i/image/M00/89/6A/CgqCHl_YT1qAUSuVAAC-xZcsk54138.png"><meta property="og:image" content="https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJDaAC6-qAACIdJOIg3E041.png"><meta property="og:image" content="https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJEOAMfdIAAJ8aDhIGdA549.png"><meta property="og:image" content="https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJHSAL8SuAAHP-0rTPKY784.png"><meta property="og:image" content="https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJRiAP2doAAKt-ZhwxQ0744.png"><meta property="og:image" content="https://s0.lgstatic.com/i/image/M00/67/59/Ciqc1F-hJYCAWVjCAAEtNT9pGHA170.png"><meta property="og:image" content="https://s0.lgstatic.com/i/image/M00/67/59/Ciqc1F-hJTGANs5yAAD4e6ACv8Q643.png"><meta property="og:image" content="https://s0.lgstatic.com/i/image/M00/67/59/Ciqc1F-hJUWAe27kAAC_6mxli_Q918.png"><meta property="og:image" content="https://s0.lgstatic.com/i/image/M00/67/65/CgqCHl-hJeCAY_aoAAF7Tt5bK8k880.png"><meta property="og:image" content="https://s0.lgstatic.com/i/image/M00/67/65/CgqCHl-hJe2ATIhGAAHpze3gFHg893.png"><meta property="article:published_time" content="2022-12-31T16:00:00.000Z"><meta property="article:modified_time" content="2023-06-19T07:44:30.670Z"><meta property="article:author" content="ZhangLK"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="React"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://s0.lgstatic.com/i/image/M00/89/5F/Ciqc1F_YT0uAT1kZAACw9EfbQe8557.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://zzzhanglk.github.io/2023/01/01/frontEnd/inDepthAndSimpleReact/reactStudy-EP8/"},"headline":"EP08 深入 React-Hook 工作机制：“原则”的背后，是“原理”","image":["https://s0.lgstatic.com/i/image/M00/89/5F/Ciqc1F_YT0uAT1kZAACw9EfbQe8557.png","https://s0.lgstatic.com/i/image/M00/89/6A/CgqCHl_YT1qAUSuVAAC-xZcsk54138.png","https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJDaAC6-qAACIdJOIg3E041.png","https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJEOAMfdIAAJ8aDhIGdA549.png","https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJHSAL8SuAAHP-0rTPKY784.png","https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJRiAP2doAAKt-ZhwxQ0744.png","https://s0.lgstatic.com/i/image/M00/67/59/Ciqc1F-hJYCAWVjCAAEtNT9pGHA170.png","https://s0.lgstatic.com/i/image/M00/67/59/Ciqc1F-hJTGANs5yAAD4e6ACv8Q643.png","https://s0.lgstatic.com/i/image/M00/67/59/Ciqc1F-hJUWAe27kAAC_6mxli_Q918.png","https://s0.lgstatic.com/i/image/M00/67/65/CgqCHl-hJeCAY_aoAAF7Tt5bK8k880.png","https://s0.lgstatic.com/i/image/M00/67/65/CgqCHl-hJe2ATIhGAAHpze3gFHg893.png"],"datePublished":"2022-12-31T16:00:00.000Z","dateModified":"2023-06-19T07:44:30.670Z","author":{"@type":"Person","name":"ZhangLK"},"publisher":{"@type":"Organization","name":"坐和放宽","logo":{"@type":"ImageObject","url":"https://fastly.jsdelivr.net/gh/ZzzhangLK/Image-Hosting-Service/img/avtor.png"}},"description":"深入 React-Hook 工作机制：“原则”的背后，是“原理”"}</script><link rel="canonical" href="http://zzzhanglk.github.io/2023/01/01/frontEnd/inDepthAndSimpleReact/reactStudy-EP8/"><link rel="icon" href="https://fastly.jsdelivr.net/gh/ZzzhangLK/Image-Hosting-Service/img/avtor.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.0.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://fastly.jsdelivr.net/gh/ZzzhangLK/Image-Hosting-Service/img/avtor.png" alt="坐和放宽" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ZzzhangLK"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-12-31T16:00:00.000Z" title="2023/1/1 00:00:00">2023-01-01</time>发表</span><span class="level-item"><time dateTime="2023-06-19T07:44:30.670Z" title="2023/6/19 15:44:30">2023-06-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/frontEnd/">frontEnd</a></span><span class="level-item">29 分钟读完 (大约4291个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">EP08 深入 React-Hook 工作机制：“原则”的背后，是“原理”</h1><div class="content"><h3 id="深入-React-Hook-工作机制：“原则”的背后，是“原理”"><a href="#深入-React-Hook-工作机制：“原则”的背后，是“原理”" class="headerlink" title="深入 React-Hook 工作机制：“原则”的背后，是“原理”"></a>深入 React-Hook 工作机制：“原则”的背后，是“原理”</h3><span id="more"></span>

<p data-nodeid="8633" class="">React 团队面向开发者给出了两条 React-Hooks 的使用原则，原则的内容如下：</p>
<ol data-nodeid="8634">
<li data-nodeid="8635">
<p data-nodeid="8636">只在 React 函数中调用 Hook；</p>
</li>
<li data-nodeid="8637">
<p data-nodeid="8638">不要在循环、条件或嵌套函数中调用 Hook。</p>
</li>
</ol>
<p data-nodeid="8639">原则 1 无须多言，React-Hooks 本身就是 React 组件的“钩子”，在普通函数里引入意义不大。我相信更多的人在原则 2 上栽过跟头，或者说至今仍然对它半信半疑。其实，原则 2 中强调的所有“<strong data-nodeid="8722">不要</strong>”，都是在指向同一个目的，那就是<strong data-nodeid="8723">要确保 Hooks 在每次渲染时都保持同样的执行顺序</strong>。</p>
<p data-nodeid="8640">为什么顺序如此重要？这就要从 Hooks 的实现机制说起了。这里我就以 useState 为例，带你从现象入手，深度探索一番 React-Hooks 的工作原理。</p>
<p data-nodeid="8641">注：本讲 Demo 基于 React 16.8.x 版本进行演示。</p>
<h3 data-nodeid="8642">从现象看问题：若不保证 Hooks 执行顺序，会带来什么麻烦？</h3>
<p data-nodeid="8643">先来看一个小 Demo：</p>
<pre class="lang-javascript" data-nodeid="8644"><code data-language="javascript"><span class="hljs-keyword">import</span> React, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<p><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PersonalInfoComponent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">&#x2F;&#x2F; 集中定义变量</span><br>  <span class="hljs-keyword">let</span> name, age, career, setName, setCareer;</p>
<p>  <span class="hljs-comment">&#x2F;&#x2F; 获取姓名状态</span><br>  [name, setName] &#x3D; useState(<span class="hljs-string">“修言”</span>);</p>
<p>  <span class="hljs-comment">&#x2F;&#x2F; 获取年龄状态</span><br>  [age] &#x3D; useState(<span class="hljs-string">“99”</span>);</p>
<p>  <span class="hljs-comment">&#x2F;&#x2F; 获取职业状态</span><br>  [career, setCareer] &#x3D; useState(<span class="hljs-string">“我是一个前端，爱吃小熊饼干”</span>);</p>
<p>  <span class="hljs-comment">&#x2F;&#x2F; 输出职业信息</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">“career”</span>, career);</p>
<p>  <span class="hljs-comment">&#x2F;&#x2F; 编写 UI 逻辑</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>&#x3D;<span class="hljs-string">“personalInfo”</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：&#123;name&#125;<span class="hljs-tag">&lt;&#x2F;<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：&#123;age&#125;<span class="hljs-tag">&lt;&#x2F;<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>职业：&#123;career&#125;<span class="hljs-tag">&lt;&#x2F;<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span><br>        <span class="hljs-attr">onClick</span>&#x3D;<span class="hljs-string">&#123;()</span> &#x3D;&gt;</span> &#123;<br>          setName(“秀妍”);<br>        &#125;&#125;<br>      &gt;<br>        修改姓名<br>      <span class="hljs-tag">&lt;&#x2F;<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;&#x2F;<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;</p>
<p><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> PersonalInfoComponent;<br></code></pre></p>
<p data-nodeid="8645">这个 PersonalInfoComponent 组件渲染出来的界面长这样：</p>
<p data-nodeid="8646"><img src="https://s0.lgstatic.com/i/image/M00/89/5F/Ciqc1F_YT0uAT1kZAACw9EfbQe8557.png" alt="1.png" data-nodeid="8731"></p>
<p data-nodeid="10684" class="te-preview-highlight">PersonalInfoComponent 用于对个人信息进行展示，这里展示的内容包括姓名、年龄、职业。出于测试效果需要，PersonalInfoComponent 还允许你点击“修改姓名”按钮修改姓名信息。点击一次后，“修言”会被修改为“秀妍”，如下图所示：</p>





<p data-nodeid="8648"><img src="https://s0.lgstatic.com/i/image/M00/89/6A/CgqCHl_YT1qAUSuVAAC-xZcsk54138.png" alt="2.png" data-nodeid="8735"></p>
<p data-nodeid="8649">到目前为止，组件的行为都是符合我们的预期的，一切看上去都是那么的和谐。但倘若我对代码做一丝小小的改变，把一部分的 useState 操作放进 if 语句里，事情就会变得大不一样。改动后的代码如下：</p>
<pre class="lang-js" data-nodeid="8650"><code data-language="js"><span class="hljs-keyword">import</span> React, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-comment">// isMounted 用于记录是否已挂载（是否是首次渲染）</span>
<span class="hljs-keyword">let</span> isMounted = <span class="hljs-literal">false</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PersonalInfoComponent</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// 定义变量的逻辑不变</span>
  <span class="hljs-keyword">let</span> name, age, career, setName, setCareer;

<p>  <span class="hljs-comment">&#x2F;&#x2F; 这里追加对 isMounted 的输出，这是一个 debug 性质的操作</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">“isMounted is”</span>, isMounted);<br>  <span class="hljs-comment">&#x2F;&#x2F; 这里追加 if 逻辑：只有在首次渲染（组件还未挂载）时，才获取 name、age 两个状态</span><br>  <span class="hljs-keyword">if</span> (!isMounted) &#123;<br>    <span class="hljs-comment">&#x2F;&#x2F; eslint-disable-next-line</span><br>    [name, setName] &#x3D; useState(<span class="hljs-string">“修言”</span>);<br>    <span class="hljs-comment">&#x2F;&#x2F; eslint-disable-next-line</span><br>    [age] &#x3D; useState(<span class="hljs-string">“99”</span>);</p>
<pre><code>&lt;span class=&quot;hljs-comment&quot;&gt;// if 内部的逻辑执行一次后，就将 isMounted 置为 true（说明已挂载，后续都不再是首次渲染了）&lt;/span&gt;
isMounted = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;
</code></pre>
<p>  }</p>
<p>  <span class="hljs-comment">&#x2F;&#x2F; 对职业信息的获取逻辑不变</span><br>  [career, setCareer] &#x3D; useState(<span class="hljs-string">“我是一个前端，爱吃小熊饼干”</span>);<br>  <span class="hljs-comment">&#x2F;&#x2F; 这里追加对 career 的输出，这也是一个 debug 性质的操作</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">“career”</span>, career);<br>  <span class="hljs-comment">&#x2F;&#x2F; UI 逻辑的改动在于，name和age成了可选的展示项，若值为空，则不展示</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>&#x3D;<span class="hljs-string">“personalInfo”</span>&gt;</span><br>      {name ? <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：{name}<span class="hljs-tag">&lt;&#x2F;<span class="hljs-name">p</span>&gt;</span> : null}<br>      {age ? <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{age}<span class="hljs-tag">&lt;&#x2F;<span class="hljs-name">p</span>&gt;</span> : null}<br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>职业：{career}<span class="hljs-tag">&lt;&#x2F;<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span><br>        <span class="hljs-attr">onClick</span>&#x3D;<span class="hljs-string">{()</span> &#x3D;&gt;</span> {<br>          setName(“秀妍”);<br>        }}<br>      &gt;<br>        修改姓名<br>      <span class="hljs-tag">&lt;&#x2F;<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;&#x2F;<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>}<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> PersonalInfoComponent;<br></code></pre></p>
<p data-nodeid="8651">修改后的组件在初始渲染的时候，界面与上个版本无异：</p>
<p data-nodeid="8652"><img src="https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJDaAC6-qAACIdJOIg3E041.png" alt="Drawing 5.png" data-nodeid="8740"></p>
<p data-nodeid="8653">注意，你在自己电脑上模仿这段代码的时候，千万不要漏掉 if 语句里面<code data-backticks="1" data-nodeid="8742">// eslint-disable-next-line</code>这个注释——因为目前大部分的 React 项目都在内部预置了对 React-Hooks-Rule（React-Hooks 使用规则）的强校验，而示例代码中把 Hooks 放进 if 语句的操作作为一种不合规操作，会被直接识别为 Error 级别的错误，进而导致程序报错。这里我们只有将相关代码的 eslint 校验给禁用掉，才能够避免校验性质的报错，从而更直观地看到错误的效果到底是什么样的，进而理解错误的原因。</p>
<p data-nodeid="8654">修改后的组件在初始挂载的时候，实际执行的逻辑内容和上个版本是没有区别的，都涉及对 name、age、career 三个状态的获取和渲染。理论上来说，<strong data-nodeid="8749">变化应该发生在我单击“修改姓名”之后触发的二次渲染里</strong>：二次渲染时，isMounted 已经被置为 true，if 内部的逻辑会被直接跳过。此时按照代码注释中给出的设计意图，这里我希望在二次渲染时，只获取并展示 career 这一个状态。那么事情是否会如我所愿呢？我们一起来看看单击“修改姓名”按钮后会发生什么：</p>
<p data-nodeid="8655"><img src="https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJEOAMfdIAAJ8aDhIGdA549.png" alt="Drawing 7.png" data-nodeid="8752"></p>
<p data-nodeid="8656">组件不仅没有像预期中一样发生界面变化，甚至直接报错了。报错信息提醒我们，这是因为“<strong data-nodeid="8758">组件渲染的 Hooks 比期望中更少</strong>”。</p>
<p data-nodeid="8657">确实，按照现有的逻辑，初始渲染调用了三次 useState，而二次渲染时只会调用一次。但仅仅因为这个，就要报错吗？</p>
<p data-nodeid="8658">按道理来说，二次渲染的时候，只要我获取到的 career 值没有问题，那么渲染就应该是没有问题的（因为二次渲染实际只会渲染 career 这一个状态），React 就没有理由阻止我的渲染动作。啊这……难道是 career 出问题了吗？还好我们预先留了一手 Debug 逻辑，每次渲染的时候都会尝试去输出一次 isMounted 和 career 这两个变量的值。现在我们就赶紧来看看，这两个变量到底是什么情况。</p>
<p data-nodeid="8659">首先我将界面重置回初次挂载的状态，观察控制台的输出，如下图所示：</p>
<p data-nodeid="8660"><img src="https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJHSAL8SuAAHP-0rTPKY784.png" alt="Drawing 9.png" data-nodeid="8764"></p>
<p data-nodeid="8661">这里我把关键的 isMounted 和 career 两个变量用红色框框圈了出来：isMounted 值为 false，说明是初次渲染；career 值为“我是一个前端，爱吃小熊饼干”，这也是没有问题的。</p>
<p data-nodeid="8662">接下来单击“修改姓名”按钮后，我们再来看一眼两个变量的内容，如下图所示：</p>
<p data-nodeid="8663"><img src="https://s0.lgstatic.com/i/image/M00/67/64/CgqCHl-hJRiAP2doAAKt-ZhwxQ0744.png" alt="图片11.png" data-nodeid="8769"></p>
<p data-nodeid="8664">二次渲染时，isMounted 为 true，这个没毛病。但是 career 竟然被修改为了“秀妍”，这也太诡异了？代码里面可不是这么写的。赶紧回头确认一下按钮单击事件的回调内容，代码如下所示：</p>
<pre class="lang-js" data-nodeid="8665"><code data-language="js"> &lt;button
   onClick=&#123;() =&gt; &#123;
    setName(<span class="hljs-string">"秀妍"</span>);
  &#125;&#125;
   &gt;
  修改姓名
&lt;/button&gt;
</code></pre>
<p data-nodeid="8666">确实，代码是没错的，我们调用的是 setName，那么它修改的状态也应该是 name，而不是 career。</p>
<p data-nodeid="8667">那为什么最后发生变化的竟然是 career 呢？年轻人，不如我们一起来看一看 Hooks 的实现机制吧！</p>
<h3 data-nodeid="8668">从源码调用流程看原理：Hooks 的正常运作，在底层依赖于顺序链表</h3>
<p data-nodeid="8669">这里强调“源码流程”而非“源码”，主要有两方面的考虑：</p>
<ol data-nodeid="8670">
<li data-nodeid="8671">
<p data-nodeid="8672">React-Hooks 在源码层面和 Fiber 关联十分密切，我们目前仍然处于基础夯实阶段，对 Fiber 机制相关的底层实现暂时没有讨论，盲目啃源码在这个阶段来说没有意义；</p>
</li>
<li data-nodeid="8673">
<p data-nodeid="8674">原理 !== 源码，阅读源码只是掌握原理的一种手段，在某些场景下，阅读源码确实能够迅速帮我们定位到问题的本质（比如 React.createElement 的源码就可以快速帮我们理解 JSX 转换出来的到底是什么东西）；而 React-Hooks 的源码链路相对来说比较长，涉及的关键函数 renderWithHooks 中“脏逻辑”也比较多，整体来说，学习成本比较高，学习效果也难以保证。</p>
</li>
</ol>
<p data-nodeid="8675">综上所述，这里我不会精细地贴出每一行具体的源码，而是针对关键方法做重点分析。同时我也<strong data-nodeid="8788">不建议你在对 Fiber 底层实现没有认知的前提下去和 Hooks 源码死磕</strong>。对于搞清楚“Hooks 的执行顺序为什么必须一样”这个问题来说，重要的并不是去细抠每一行代码到底都做了什么，而是要搞清楚整个<strong data-nodeid="8789">调用链路</strong>是什么样的。如果我们能够理解 Hooks 在每个关键环节都做了哪些事情，同时也能理解这些关键环节是如何对最终的渲染结果产生影响的，那么理解 Hooks 的工作机制对于你来说就不在话下了。</p>
<h4 data-nodeid="8676">以 useState 为例，分析 React-Hooks 的调用链路</h4>
<p data-nodeid="8677">首先要说明的是，React-Hooks 的调用链路在首次渲染和更新阶段是不同的，这里我将两个阶段的链路各总结进了两张大图里，我们依次来看。首先是首次渲染的过程，请看下图：</p>
<p data-nodeid="8678"><img src="https://s0.lgstatic.com/i/image/M00/67/59/Ciqc1F-hJYCAWVjCAAEtNT9pGHA170.png" alt="图片12.png" data-nodeid="8794"></p>
<p data-nodeid="8679">在这个流程中，useState 触发的一系列操作最后会落到 mountState 里面去，所以我们重点需要关注的就是 mountState 做了什么事情。以下我为你提取了 mountState 的源码：</p>
<pre class="lang-java" data-nodeid="8680"><code data-language="java"><span class="hljs-comment">// 进入 mounState 逻辑</span>
<span class="hljs-function">function <span class="hljs-title">mountState</span><span class="hljs-params">(initialState)</span> </span>&#123;

<p>  <span class="hljs-comment">&#x2F;&#x2F; 将新的 hook 对象追加进链表尾部</span><br>  <span class="hljs-keyword">var</span> hook &#x3D; mountWorkInProgressHook();</p>
<p>  <span class="hljs-comment">&#x2F;&#x2F; initialState 可以是一个回调，若是回调，则取回调执行后的值</span><br>  <span class="hljs-keyword">if</span> (typeof initialState &#x3D;&#x3D;&#x3D; <span class="hljs-string">‘function’</span>) &#123;<br>    <span class="hljs-comment">&#x2F;&#x2F; $FlowFixMe: Flow doesn’t like mixed types</span><br>    initialState &#x3D; initialState();<br>  &#125;</p>
<p>  <span class="hljs-comment">&#x2F;&#x2F; 创建当前 hook 对象的更新队列，这一步主要是为了能够依序保留 dispatch</span><br>  <span class="hljs-keyword">const</span> queue &#x3D; hook.queue &#x3D; &#123;<br>    last: <span class="hljs-keyword">null</span>,<br>    dispatch: <span class="hljs-keyword">null</span>,<br>    lastRenderedReducer: basicStateReducer,<br>    lastRenderedState: (initialState: any),<br>  &#125;;</p>
<p>  <span class="hljs-comment">&#x2F;&#x2F; 将 initialState 作为一个“记忆值”存下来</span><br>  hook.memoizedState &#x3D; hook.baseState &#x3D; initialState;</p>
<p>  <span class="hljs-comment">&#x2F;&#x2F; dispatch 是由上下文中一个叫 dispatchAction 的方法创建的，这里不必纠结这个方法具体做了什么</span><br>  <span class="hljs-keyword">var</span> dispatch &#x3D; queue.dispatch &#x3D; dispatchAction.bind(<span class="hljs-keyword">null</span>, currentlyRenderingFiber$<span class="hljs-number">1</span>, queue);<br>  <span class="hljs-comment">&#x2F;&#x2F; 返回目标数组，dispatch 其实就是示例中常常见到的 setXXX 这个函数，想不到吧？哈哈</span><br>  <span class="hljs-keyword">return</span> [hook.memoizedState, dispatch];<br>&#125;<br></code></pre></p>
<p data-nodeid="8681">从这段源码中我们可以看出，<strong data-nodeid="8801">mounState 的主要工作是初始化 Hooks</strong>。在整段源码中，最需要关注的是 mountWorkInProgressHook 方法，它为我们道出了 Hooks 背后的数据结构组织形式。以下是 mountWorkInProgressHook 方法的源码：</p>
<pre class="lang-java" data-nodeid="8682"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">mountWorkInProgressHook</span><span class="hljs-params">()</span> </span>&#123;
  <span class="hljs-comment">// 注意，单个 hook 是以对象的形式存在的</span>
  <span class="hljs-keyword">var</span> hook = &#123;
    memoizedState: <span class="hljs-keyword">null</span>,
    baseState: <span class="hljs-keyword">null</span>,
    baseQueue: <span class="hljs-keyword">null</span>,
    queue: <span class="hljs-keyword">null</span>,
    next: <span class="hljs-keyword">null</span>
  &#125;;
  <span class="hljs-keyword">if</span> (workInProgressHook === <span class="hljs-keyword">null</span>) &#123;
    <span class="hljs-comment">// 这行代码每个 React 版本不太一样，但做的都是同一件事：将 hook 作为链表的头节点处理</span>
    firstWorkInProgressHook = workInProgressHook = hook;
  &#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">// 若链表不为空，则将 hook 追加到链表尾部</span>
    workInProgressHook = workInProgressHook.next = hook;
  &#125;
  <span class="hljs-comment">// 返回当前的 hook</span>
  <span class="hljs-keyword">return</span> workInProgressHook;
&#125;
</code></pre>
<p data-nodeid="8683">到这里可以看出，<strong data-nodeid="8807">hook 相关的所有信息收敛在一个 hook 对象里，而 hook 对象之间以单向链表的形式相互串联</strong>。</p>
<p data-nodeid="8684">接下来我们再看更新过程的大图：</p>
<p data-nodeid="8685"><img src="https://s0.lgstatic.com/i/image/M00/67/59/Ciqc1F-hJTGANs5yAAD4e6ACv8Q643.png" alt="图片13.png" data-nodeid="8811"></p>
<p data-nodeid="8686">根据图中高亮部分的提示不难看出，首次渲染和更新渲染的区别，在于调用的是 mountState，还是 updateState。mountState 做了什么，你已经非常清楚了；而 updateState 之后的操作链路，虽然涉及的代码有很多，但其实做的事情很容易理解：<strong data-nodeid="8817">按顺序去遍历之前构建好的链表，取出对应的数据信息进行渲染</strong>。</p>
<p data-nodeid="8687">我们把 mountState 和 updateState 做的事情放在一起来看：mountState（首次渲染）构建链表并渲染；updateState 依次遍历链表并渲染。</p>
<p data-nodeid="8688">看到这里，你是不是已经大概知道怎么回事儿了？没错，<strong data-nodeid="8824">hooks 的渲染是通过“依次遍历”来定位每个 hooks 内容的。如果前后两次读到的链表在顺序上出现差异，那么渲染的结果自然是不可控的</strong>。</p>
<p data-nodeid="8689">这个现象有点像我们构建了一个长度确定的数组，数组中的每个坑位都对应着一块确切的信息，后续每次从数组里取值的时候，只能够通过索引（也就是位置）来定位数据。也正因为如此，在许多文章里，都会直截了当地下这样的定义：Hooks 的本质就是数组。但读完这一课时的内容你就会知道，<strong data-nodeid="8830">Hooks 的本质其实是链表</strong>。</p>
<p data-nodeid="8690">接下来我们把这个已知的结论还原到 PersonalInfoComponent 里去，看看实际项目中，变量到底是怎么发生变化的。</p>
<h3 data-nodeid="8691">站在底层视角，重现 PersonalInfoComponent 组件的执行过程</h3>
<p data-nodeid="8692">我们先来复习一下修改过后的 PersonalInfoComponent 组件代码：</p>
<pre class="lang-js" data-nodeid="8693"><code data-language="js"><span class="hljs-keyword">import</span> React, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-comment">// isMounted 用于记录是否已挂载（是否是首次渲染）</span>
<span class="hljs-keyword">let</span> isMounted = <span class="hljs-literal">false</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PersonalInfoComponent</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-comment">// 定义变量的逻辑不变</span>
  <span class="hljs-keyword">let</span> name, age, career, setName, setCareer;

<p>  <span class="hljs-comment">&#x2F;&#x2F; 这里追加对 isMounted 的输出，这是一个 debug 性质的操作</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">“isMounted is”</span>, isMounted);<br>  <span class="hljs-comment">&#x2F;&#x2F; 这里追加 if 逻辑：只有在首次渲染（组件还未挂载）时，才获取 name、age 两个状态</span><br>  <span class="hljs-keyword">if</span> (!isMounted) &#123;<br>    <span class="hljs-comment">&#x2F;&#x2F; eslint-disable-next-line</span><br>    [name, setName] &#x3D; useState(<span class="hljs-string">“修言”</span>);<br>    <span class="hljs-comment">&#x2F;&#x2F; eslint-disable-next-line</span><br>    [age] &#x3D; useState(<span class="hljs-string">“99”</span>);</p>
<pre><code>&lt;span class=&quot;hljs-comment&quot;&gt;// if 内部的逻辑执行一次后，就将 isMounted 置为 true（说明已挂载，后续都不再是首次渲染了）&lt;/span&gt;
isMounted = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;
</code></pre>
<p>  }</p>
<p>  <span class="hljs-comment">&#x2F;&#x2F; 对职业信息的获取逻辑不变</span><br>  [career, setCareer] &#x3D; useState(<span class="hljs-string">“我是一个前端，爱吃小熊饼干”</span>);<br>  <span class="hljs-comment">&#x2F;&#x2F; 这里追加对 career 的输出，这也是一个 debug 性质的操作</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">“career”</span>, career);<br>  <span class="hljs-comment">&#x2F;&#x2F; UI 逻辑的改动在于，name 和 age 成了可选的展示项，若值为空，则不展示</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>&#x3D;<span class="hljs-string">“personalInfo”</span>&gt;</span><br>      {name ? <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：{name}<span class="hljs-tag">&lt;&#x2F;<span class="hljs-name">p</span>&gt;</span> : null}<br>      {age ? <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{age}<span class="hljs-tag">&lt;&#x2F;<span class="hljs-name">p</span>&gt;</span> : null}<br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>职业：{career}<span class="hljs-tag">&lt;&#x2F;<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span><br>        <span class="hljs-attr">onClick</span>&#x3D;<span class="hljs-string">{()</span> &#x3D;&gt;</span> {<br>          setName(“秀妍”);<br>        }}<br>      &gt;<br>        修改姓名<br>      <span class="hljs-tag">&lt;&#x2F;<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;&#x2F;<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>}<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> PersonalInfoComponent;<br></code></pre></p>
<p data-nodeid="8694">从代码里面，我们可以提取出来的 useState 调用有三个：</p>
<pre class="lang-java" data-nodeid="8695"><code data-language="java">[name, setName] = useState(<span class="hljs-string">"修言"</span>);
[age] = useState(<span class="hljs-string">"99"</span>);
[career, setCareer] = useState(<span class="hljs-string">"我是一个前端，爱吃小熊饼干"</span>);
</code></pre>
<p data-nodeid="8696">这三个调用在首次渲染的时候都会发生，伴随而来的链表结构如图所示：</p>
<p data-nodeid="8697"><img src="https://s0.lgstatic.com/i/image/M00/67/59/Ciqc1F-hJUWAe27kAAC_6mxli_Q918.png" alt="图片14.png" data-nodeid="8838"></p>
<p data-nodeid="8698">当首次渲染结束，进行二次渲染的时候，实际发生的 useState 调用只有一个：</p>
<pre class="lang-java" data-nodeid="8699"><code data-language="java">useState(<span class="hljs-string">"我是一个前端，爱吃小熊饼干"</span>)
</code></pre>
<p data-nodeid="8700">而此时的链表情况如下图所示：</p>
<p data-nodeid="8701"><img src="https://s0.lgstatic.com/i/image/M00/67/65/CgqCHl-hJeCAY_aoAAF7Tt5bK8k880.png" alt="图片15.png" data-nodeid="8843"></p>
<p data-nodeid="8702">我们再复习一遍更新（二次渲染）的时候会发生什么事情：updateState 会依次遍历链表、读取数据并渲染。注意这个过程就像从数组中依次取值一样，是完全按照顺序（或者说索引）来的。因此 React 不会看你命名的变量名是 career 还是别的什么，它只认你这一次 useState 调用，于是它难免会认为：<strong data-nodeid="8849">喔，原来你想要的是第一个位置的 hook 啊</strong>。</p>
<p data-nodeid="8703">然后就会有下面这样的效果：</p>
<p data-nodeid="8704"><img src="https://s0.lgstatic.com/i/image/M00/67/65/CgqCHl-hJe2ATIhGAAHpze3gFHg893.png" alt="图片16.png" data-nodeid="8853"></p>
<p data-nodeid="8705">如此一来，career 就自然而然地取到了链表头节点 hook 对象中的“秀妍”这个值。</p>
<h3 data-nodeid="8706">总结</h3>
<p data-nodeid="8707">三个课时学完了，到这里，我们对 React-Hooks 的学习，才终于算是告一段落。</p>
<p data-nodeid="8708">在过去的三个课时里，我们摸排了“动机”，认知了“工作模式”，最后更是结合源码、深挖了一把 React-Hooks 的底层原理。我们所做的这所有的努力，都是为了能够真正吃透 React-Hooks，不仅要确保实践中不出错，还要做到面试时有底气。</p>
<p data-nodeid="8709" class="">接下来，我们就将进入整个专栏真正的“深水区”，逐步切入“虚拟 DOM → Diff 算法 → Fiber 架构”这个知识链路里来。在后续的学习中，我们将延续并且强化这种“刨根问底”的风格，紧贴源码、原理和面试题来向 React 最为核心的部分发起挑战。真正的战斗，才刚刚开始，大家加油~</p></div><div class="article-licensing box"><div class="licensing-title"><p>EP08 深入 React-Hook 工作机制：“原则”的背后，是“原理”</p><p><a href="http://zzzhanglk.github.io/2023/01/01/frontEnd/inDepthAndSimpleReact/reactStudy-EP8/">http://zzzhanglk.github.io/2023/01/01/frontEnd/inDepthAndSimpleReact/reactStudy-EP8/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>ZhangLK</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-01-01</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-06-19</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/JavaScript/">JavaScript</a><a class="link-muted mr-2" rel="tag" href="/tags/React/">React</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://fastly.jsdelivr.net/gh/ZzzhangLK/Image-Hosting-Service/img/alipay.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://fastly.jsdelivr.net/gh/ZzzhangLK/Image-Hosting-Service/img/wechat.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/02/01/frontEnd/inDepthAndSimpleReact/reactStudy-EP9/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">EP09 真正理解虚拟 DOM：React 选它，真的是为了性能吗？</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/12/22/frontEnd/inDepthAndSimpleReact/reactStudy-EP7/"><span class="level-item">EP07 React-Hook 设计动机与工作模式（下）</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Finance/"><span class="level-start"><span class="level-item">Finance</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/FrontEnd/"><span class="level-start"><span class="level-item">FrontEnd</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Thoughts/"><span class="level-start"><span class="level-item">Thoughts</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/article/"><span class="level-start"><span class="level-item">article</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/article/frontEnd/"><span class="level-start"><span class="level-item">frontEnd</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/essay/"><span class="level-start"><span class="level-item">essay</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/frontEnd/"><span class="level-start"><span class="level-item">frontEnd</span></span><span class="level-end"><span class="level-item tag">22</span></span></a><ul><li><a class="level is-mobile" href="/categories/frontEnd/JavaScript/"><span class="level-start"><span class="level-item">JavaScript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/DOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/"><span class="tag">DOM编程艺术</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo%E4%B8%BB%E9%A2%98/"><span class="tag">Hexo主题</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React/"><span class="tag">React</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/blog/"><span class="tag">blog</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/blog-%E5%9B%BE%E5%BA%8A/"><span class="tag">blog - 图床</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/"><span class="tag">专项练习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B/"><span class="tag">变量和类型</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E5%BA%8A/"><span class="tag">图床</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="tag">小程序</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%89%BE%E5%B7%A5%E4%BD%9C/"><span class="tag">找工作</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%80%83%E7%A0%94/"><span class="tag">考研</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AC%E8%BD%BD/"><span class="tag">转载</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%87%8D%E5%AD%A6JS/"><span class="tag">重学JS</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%87%91%E8%9E%8D/"><span class="tag">金融</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%94%99%E9%A2%98%E6%9C%AC/"><span class="tag">错题本</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9A%8F%E6%83%B3/"><span class="tag">随想</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9A%8F%E7%AC%94/"><span class="tag">随笔</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tag">面试</span><span class="tag">3</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-07-01T12:00:00.000Z">2023-07-01</time></p><p class="title"><a href="/2023/07/01/frontEnd/nowcoder/frontEnd-interview/">面试问题记录</a></p><p class="categories"><a href="/categories/article/">article</a> / <a href="/categories/article/frontEnd/">frontEnd</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-06-30T12:00:00.000Z">2023-06-30</time></p><p class="title"><a href="/2023/06/30/frontEnd/nowcoder/interview/">面试问题预判</a></p><p class="categories"><a href="/categories/article/">article</a> / <a href="/categories/article/frontEnd/">frontEnd</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-01-31T16:00:00.000Z">2023-02-01</time></p><p class="title"><a href="/2023/02/01/frontEnd/inDepthAndSimpleReact/reactStudy-EP9/">EP09 真正理解虚拟 DOM：React 选它，真的是为了性能吗？</a></p><p class="categories"><a href="/categories/frontEnd/">frontEnd</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-31T16:00:00.000Z">2023-01-01</time></p><p class="title"><a href="/2023/01/01/frontEnd/inDepthAndSimpleReact/reactStudy-EP8/">EP08 深入 React-Hook 工作机制：“原则”的背后，是“原理”</a></p><p class="categories"><a href="/categories/frontEnd/">frontEnd</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-12-21T16:00:00.000Z">2022-12-22</time></p><p class="title"><a href="/2022/12/22/frontEnd/inDepthAndSimpleReact/reactStudy-EP7/">EP07 React-Hook 设计动机与工作模式（下）</a></p><p class="categories"><a href="/categories/frontEnd/">frontEnd</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://fastly.jsdelivr.net/gh/ZzzhangLK/Image-Hosting-Service/img/avtor.png" alt="坐和放宽" height="28"></a><p class="is-size-7"><span>&copy; 2023 ZhangLK</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ZzzhangLK"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>